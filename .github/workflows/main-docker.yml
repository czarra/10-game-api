# .github/workflows/master-docker.yml
name: 'Build, Push and Deploy to Production'

on:
  workflow_dispatch:

jobs:
  lint:
    name: 'Lint'
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v4

      - name: 'Set up PHP'
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: gd, zip, pdo, pdo_pgsql, opcache
          tools: composer, phpstan

      - name: 'Cache Composer dependencies'
        uses: actions/cache@v4
        with:
          path: ~/.composer/cache/files
          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-

      - name: 'Install dependencies'
        run: composer install --prefer-dist --no-progress --no-suggest
        env:
          APP_ENV: test
          DATABASE_URL: 'sqlite:///%kernel.project_dir%/var/data.db'

      - name: 'Run PHPStan'
        run: phpstan analyse

  unit-tests:
    name: 'Unit Tests'
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v4

      - name: 'Set up PHP'
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: gd, zip, pdo, pdo_pgsql, opcache
          tools: composer

      - name: 'Cache Composer dependencies'
        uses: actions/cache@v4
        with:
          path: ~/.composer/cache/files
          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-

      - name: 'Install dependencies'
        run: composer install --prefer-dist --no-progress --no-suggest
        env:
          APP_ENV: test
          DATABASE_URL: 'sqlite:///%kernel.project_dir%/var/data.db'

      - name: 'Run Unit Tests'
        run: vendor/bin/phpunit --testsuite Unit

  build-and-push:
    name: 'Build and Push Docker Image'
    needs: unit-tests
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}

    steps:
      - name: 'Checkout'
        uses: actions/checkout@v4

      - name: 'Log in to GitHub Container Registry'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 'Extract metadata (tags, labels) for Docker'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/czarra/10-game-api
          tags: |
            type=sha,prefix=,format=short

      - name: 'Build and push Docker image'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./php/Dockerfile.prod
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            APP_ENV=prod
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-to-railway:
    name: 'Deploy to Railway'
    needs: [ build-and-push ]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: 'Install Railway CLI'
        run: npm install -g @railway/cli

      # KROK KLUCZOWY: Tworzymy "pusty" Dockerfile wskazujący na nasz gotowy obraz
      - name: 'Create Dockerfile wrapper'
        run: |
          echo "FROM ghcr.io/czarra/10-game-api:${{ needs.build-and-push.outputs.image_tag }}" > Dockerfile
          cat Dockerfile # Dla podglądu w logach

      # Wysyłamy ten Dockerfile do Railway. Railway "zbuduje" go w sekundę (bo tylko pobiera obraz)
      - name: 'Deploy Image to Railway'
        run: railway up --service ${{ secrets.RAILWAY_SERVICE_ID }} --detach
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

      # Opcjonalnie: Czekamy chwilę na wstanie kontenera (Railway up --detach nie czeka)
      # Możesz usunąć ten krok, jeśli Twoje migracje są odporne na stan wyścigu
      - name: 'Wait for deployment'
        run: sleep 10

      # Uruchamiamy komendy na nowym wdrożeniu
      - name: 'Create database if not exists'
        run: railway run --service ${{ secrets.RAILWAY_SERVICE_ID }} -- php bin/console doctrine:database:create --if-not-exists
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

      - name: 'Run Migrations'
        run: railway run --service ${{ secrets.RAILWAY_SERVICE_ID }} -- php bin/console doctrine:migrations:migrate --no-interaction --allow-no-migration
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}